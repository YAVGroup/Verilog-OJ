problems:
- name: 三个数的排序
  description: |-
    请写一个能完成三个数排序的 Verilog module。
    在本次任务中，您应该在 7 个时钟周期内进行排序。
    当您完成排序时，您应将 done 输出高电平，之后我们将会验证结果是否正确。
    您使用的资源会被作为最后的测试样例考察的内容。
    您的设计将会被综合到 Berkeley ABC 提供的标准 CMOS 工艺库，同时我们会考察您使用的总 Cell 数。
    
    请注意：虽然最后测试点和这里都给出了参考波形，但您并不需要完全遵守参考波形的排序方法和顺序。
    您只需要在您的 done 发生后排序结果正确，并满足时钟周期数的限制即可。
  description_input: |-
    您应该在 rst 信号变为 0 后开始排序。三个数字将会通过 s0, s1 和 s2 输入，均为 4-bit Wire。
    时钟信号为 clk，您应该在 7 个时钟周期内进行排序并让 done 为 1，否则记为失败。

  description_output: |-
    输出为 t0, t1, t2，均为 4-bit wire。
    您应当输出 a, b, c 三者从小到大排序后的结果。

  app_data: |-
    {"signal": [
        {"name": "clk", "wave": "101010101010101."},
        {"name": "rst", "wave": "1...0..........."},
        {"name": "done", "wave": "0.......1......."},
        {"name": "s0", "wave": "=...............", "data": [7]},
        {"name": "s1", "wave": "=...............", "data": [8]},
        {"name": "s2", "wave": "=...............", "data": [5]},
        {"name": "t0", "wave": "=.......=.......", "data": [7, 5]},
        {"name": "t1", "wave": "=.....=.=.......", "data": [8, 5, 7]},
        {"name": "t2", "wave": "=.....=.........", "data": [5, 8]}]
    }

  template_code_file:
    name: template_code.v
    content: |-
      module top_module(
            input [3:0] s0,
            input [3:0] s1,
            input [3:0] s2,
            input rst,
            input clk,
            output reg [3:0] t0,
            output reg [3:0] t1,
            output reg [3:0] t2,
            output reg done
        );
        // Write your code here
      endmodule

  judge_files:
    - name: code_ref.v
      content: |-
        module top_module(
            input [3:0] s0,
            input [3:0] s1,
            input [3:0] s2,
            input rst,
            input clk,
            output reg [3:0] t0,
            output reg [3:0] t1,
            output reg [3:0] t2,
            output reg done
        );
        reg [2:0] i;
        reg [3:0] temp;
        always @ (posedge clk) begin 
            if (rst) begin 
                t0   <= s0;
                t1   <= s1;
                t2   <= s2;
                i    <= 0;
                temp <= 0;
                done <= 0;
            end else begin
                case (i) 
                    3'd0: begin 
                        if (t0 > t1) begin
                            temp = t0; t0 = t1; t1 = temp;
                        end
                        i <= i + 3'd1;
                    end
                    3'd1: begin 
                        if (t1 > t2) begin
                            temp = t1; t1 = t2; t2 = temp;
                        end
                        i <= i + 3'd1; 
                    end
                    3'd2: begin 
                        if (t0 > t1) begin
                            temp = t0; t0 = t1; t1 = temp;
                        end
                        done <= 1;
                    end
                endcase
            end
        end
        endmodule

  testcases:
  - type: SIM
    grade: 10
    testcase_files:
    - name: wavedump.py
      content: |+
        #!/usr/bin/env python3

        """
        Example signal:

        {
            'name': 'root', 
            'type': {'name': 'struct'}, 
            'children': [
                {
                    'name': 'testbench', 
                    'type': {'name': 'struct'}, 
                    'children': [
                        {
                            'name': 'x', 
                            'type': {'width': 3, 'name': 'reg'}, 
                            'data': [
                                (0, 'bx'), (1, 'b0'), (2, 'b1'), (3, 'b10'), (4, 'b11'), (5, 'b100'), (6, 'b101'), (7, 'b110'), (8, 'b111')
                            ]
                        }, 
                        {
                            'name': 'y', 
                            'type': {
                                'width': 8, 
                                'name': 'wire'
                            }, 
                            'data': [
                                (0, 'bx'), (1, 'b1'), (2, 'b10'), (3, 'b100'), (4, 'b1000'), (5, 'b10000'), (6, 'b100000'), (7, 'b1000000'), (8, 'b10000000')
                            ]
                        }
                    ]
                }
            ]
        }

        """


        from pyDigitalWaveTools.vcd.parser import VcdParser

        class VcdSignalTraversalError(Exception):
            pass

        class VcdSignalComparationError(Exception):
            pass

        def find_signal_inst(data_obj, signal_path):
            components = signal_path.split("/")
            cur = data_obj
            for i in range(0, len(components) - 1):
                if cur['name'] != components[i]:
                    raise VcdSignalTraversalError("{} mismatch with {} while traversing {}".format(
                        cur['name'], components[i], signal_path))

                if not 'children' in cur.keys():
                    raise VcdSignalTraversalError("{} have no data k-v pair while traversing {}".format(
                        cur['name'], signal_path))

                found = False
                for child in cur['children']:
                    if child['name'] == components[i+1]:
                        found = True
                        cur = child
                        break

                if not found:
                    raise VcdSignalTraversalError("{} have no children called {} while traversing {}".format(
                        cur['name'], components[i+1], signal_path))

            if cur['name'] != components[-1]:
                raise VcdSignalTraversalError("{} mismatch with {} while traversing {}".format(
                    cur['name'], components[-1], signal_path))

            return cur

        class VcdComparator:

            def compare_signals(self, ref, ud):
                # compare width
                if ref['type']['width'] != ud['type']['width']:
                    raise VcdSignalComparationError("Signal {} have different width between ref ({}) and ud ({})".format(
                        ref['name'], ref['type']['width'], ud['type']['width']))

                # No need to compare sigType (reg/wire.. anything else?)

                # signal comparation
                # TODO: support for different types ('b0' with 'b000' or 'd0' or something...)
                
                # Since value change dump theoretically only generates data when changes
                # so direct diffing should work
                for i, val in enumerate(ref['data']):
                    if ud['data'][i] != val:
                        raise VcdSignalComparationError("Signal {} have difference on time {} (ref={}, ud={})".format(
                            ref['name'], val[0], val, ud['data'][i]))

            def dump_hierarchy(self, data_obj):
                # TODO: only dump names
                print(data_obj.toJSON())

            def __init__(self, vcd_ref, vcd_ut, signal_names):
                """Initialize signals for comparation
                vcd_ref: the reference vcd file
                vcd_ut: the vcd file under test
                signal_names: the signal for comparation, uses "/" to express hierarchy.
                        and the top module name shall also be included.
                """

                with open(vcd_ref) as vcd_ref_file:
                    vcd = VcdParser()
                    vcd.parse(vcd_ref_file)
                    self.data_ref = vcd.scope.toJson()
                    print(self.data_ref)

                with open(vcd_ut) as vcd_ut_file:
                    vcd_ut = VcdParser()
                    vcd_ut.parse(vcd_ut_file)
                    self.data_ut = vcd_ut.scope.toJson()
                    print(self.data_ut)

                # find all signals
                self.signals_ref = [find_signal_inst(self.data_ref, i) for i in signal_names]
                self.signals_ut = [find_signal_inst(self.data_ut, i) for i in signal_names]

            def compare(self):
                try:
                    # compare all signals
                    for i in range(0, len(self.signals_ref)):
                        self.compare_signals(self.signals_ref[i], self.signals_ut[i])
                    return (True, "No error")
                except VcdSignalComparationError as e:
                    return (False, "{}".format(e))

        import json

        class VcdSignalValueParseError(Exception):
            pass

        class VcdConverter:

            def __init__(self, data_vcd):
                self.output = {'signal': []}
                self.data_vcd = data_vcd
                self.global_time_max = 0

            def emitWaveDict(self):
                return self.output

            def mergeWaveDict(self, wdict):
                self.output['signal'] += wdict['signal']

            def emitWaveJson(self):
                return json.dumps(self.output)

            def parseValue(self, val_str):
                """ Note: b111xx1 -> x """
                if val_str[0] == "b":
                    if val_str.find("x") != -1:
                        return "x"
                    return int(val_str[1:], base=2)
                elif len(val_str) == 1:
                    if val_str[0] == "x":
                        return "x"
                    else:
                        return int(val_str, base=2)
                else:
                    raise VcdSignalValueParseError("Unknown value type")

            def toBinRepr(self, val, width):
                if val == 'x':
                    return 'x' * width

                striped = bin(val)[2:]
                assert(width >= len(striped))
                return "0" * (width - len(striped)) + striped

            def addToWaveJsonSeparate(self, signal_names, prefix=""):
                # find common time_max
                time_max = self.global_time_max
                for signal_name in signal_names:
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)
                    time_max = max(time_max, sig_inst['data'][-1][0])
                
                self.global_time_max = time_max

                for signal_name in signal_names:
                    sig_jsons = []
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)

                    width = sig_inst['type']['width']
                    # decompose
                    for i in range(0, width):
                        sig_jsons.append({})
                        sig_jsons[i]['name'] = prefix + sig_inst['name'] + "[" + str(i) + "]"

                    local_time_max = sig_inst['data'][-1][0]
                    waves = ["" for i in range(0, width)]
                    cur_step_ptr = 0

                    # "x" or int or "SOME.."
                    cur_wave = "SOMETHING_NEVER_HAPPEN"

                    # TODO: Avoid multiple transitions at same timestep
                    for i in range(0, local_time_max + 1):
                        if sig_inst['data'][cur_step_ptr][0] > i:
                            # maintain current value
                            for i in range(0, width):
                                waves[i] += "."
                        else:
                            new_wave = self.parseValue(sig_inst['data'][cur_step_ptr][1])
                            if new_wave == cur_wave:
                                waves[i] += "."
                            else:
                                # do bitwise comparation
                                if cur_wave == "SOMETHING_NEVER_HAPPEN":
                                    # new_wave_bin[0] is MSB
                                    new_wave_bin = self.toBinRepr(new_wave, width)
                                    for i in range(0, width):
                                        waves[i] += new_wave_bin[::-1][i]
                                else:
                                    cur_wave_bin = self.toBinRepr(cur_wave, width)
                                    new_wave_bin = self.toBinRepr(new_wave, width)

                                    for i in range(0, width):
                                        old = cur_wave_bin[::-1][i]
                                        new = new_wave_bin[::-1][i]
                                        if old != new:
                                            waves[i] += new
                                        else:
                                            waves[i] += '.'

                                cur_wave = new_wave

                            cur_step_ptr += 1

                    for i in range(local_time_max, time_max + 1):
                        for i in range(0, width):
                            waves[i] += "."

                    for i in range(0, width):
                        sig_jsons[i]['wave'] = waves[i]

                    self.output['signal'] += sig_jsons

            def addToWaveJsonAggregated(self, signal_names, prefix=""):
                """ Aggregated view, which uses '=' on every timeslice. """
                # find common time_max
                time_max = self.global_time_max
                for signal_name in signal_names:
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)
                    time_max = max(time_max, sig_inst['data'][-1][0])

                self.global_time_max = time_max

                for signal_name in signal_names:
                    sig_json = {}
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)
                    sig_json['name'] = prefix + sig_inst['name']

                    # [0, time_max]
                    local_time_max = sig_inst['data'][-1][0]
                    wave = ""
                    cur_step_ptr = 0
                    cur_wave = "SOMETHING_NEVER_HAPPEN"
                    data = []

                    # TODO: Avoid multiple transitions at same timestep
                    for i in range(0, local_time_max + 1):
                        if sig_inst['data'][cur_step_ptr][0] > i:
                            # maintain current value
                            wave += "."
                        else:
                            new_wave = self.parseValue(sig_inst['data'][cur_step_ptr][1])
                            if new_wave == cur_wave:
                                wave += "."
                            else:
                                wave += "="
                                data.append(new_wave)
                                cur_wave = new_wave

                            cur_step_ptr += 1

                    for i in range(local_time_max, time_max + 1):
                        wave += "."

                    sig_json['wave'] = wave
                    sig_json['data'] = data

                    self.output['signal'].append(sig_json)


        if __name__ == "__main__":
            sample_vcd = {'name': 'root', 'type': {'name': 'struct'}, 'children': [{'name': 'testbench', 'type': {'name': 'struct'}, 'children': [{'name': 'x', 'type': {'width': 3, 'name': 'reg'}, 'data': [(0, 'bx'), (1, 'b0'), (2, 'b1'), (3, 'b10'), (4, 'b11'), (5, 'b100'), (6, 'b101'), (7, 'b110'), (8, 'b111')]}, {'name': 'y', 'type': {'width': 8, 'name': 'wire'}, 'data': [(0, 'bx'), (1, 'b1'), (2, 'b1x'), (3, 'b100'), (4, 'b1000'), (5, 'b10000'), (6, 'b100000'), (7, 'b1000000'), (8, 'b10000000')]}]}]}
            sample_vcd2 = {'name': 'root', 'type': {'name': 'struct'}, 'children': [{'name': 'testbench', 'type': {'name': 'struct'}, 'children': [{'name': 'a', 'type': {'width': 1, 'name': 'reg'}, 'data': [(0, 'x'), (1, '0'), (2, '1'), (3, '0'), (4, '1')]}, {'name': 'b', 'type': {'width': 1, 'name': 'reg'}, 'data': [(0, 'x'), (1, '0'), (3, '1')]}, {'name': 'out', 'type': {'width': 1, 'name': 'wire'}, 'data': [(0, 'x'), (1, '1'), (2, '0'), (4, '1')]}]}]}
            vc = VcdConverter(sample_vcd)
            vc.addToWaveJsonSeparate(['root/testbench/x', 'root/testbench/y'], "mysig_")
            vc.addToWaveJsonAggregated(['root/testbench/x', 'root/testbench/y'], "mysig_")
            print(vc.emitWaveJson())

            vc2 = VcdConverter(sample_vcd2)
            vc2.addToWaveJsonSeparate(['root/testbench/a', 'root/testbench/b', 'root/testbench/out'], "mysig_")
            vc2.addToWaveJsonAggregated(['root/testbench/a', 'root/testbench/b', 'root/testbench/out'], "mysig_")
            print(vc2.emitWaveJson())

    - name: vcd_visualize.py
      content: |
        #!/usr/bin/env python3
        import sys

        def main():
            from pyDigitalWaveTools.vcd.parser import VcdParser
            from wavedump import VcdConverter

            with open("./out_ref.vcd") as vcd_ref_file:
                vcd = VcdParser()
                vcd.parse(vcd_ref_file)
                data_ref = vcd.scope.toJson()

            with open("./out_dut.vcd") as vcd_dut_file:
                vcd = VcdParser()
                vcd.parse(vcd_dut_file)
                data_dut = vcd.scope.toJson()

            vc_ref = VcdConverter(data_ref)
            vc_ref.addToWaveJsonSeparate([
                'root/testbench/clk',
                'root/testbench/rst',
                'root/testbench/done',
                'root/testbench/correct'
            ], "reference_")
            vc_ref.addToWaveJsonAggregated([
                'root/testbench/s0',
                'root/testbench/s1',
                'root/testbench/s2',
                'root/testbench/t0',
                'root/testbench/t1',
                'root/testbench/t2']
                , "reference_")

            vc_dut = VcdConverter(data_dut)
            vc_dut.addToWaveJsonSeparate([
                'root/testbench/clk',
                'root/testbench/rst',
                'root/testbench/done',
                'root/testbench/correct'
            ], "your_")
            vc_dut.addToWaveJsonAggregated([
                'root/testbench/s0',
                'root/testbench/s1',
                'root/testbench/s2',
                'root/testbench/t0',
                'root/testbench/t1',
                'root/testbench/t2']
                , "your_")

            vc_ref.mergeWaveDict(vc_dut.emitWaveDict())
            out = vc_ref.emitWaveJson()

            with open("./appdata.txt", "w") as f:
                f.write(out)

        main()

    - name: vcd_main.py
      content: |
        #!/usr/bin/env python3
        import sys

        def main():

            from wavedump import VcdComparator
            cmpr = VcdComparator("./out_ref.vcd", "./out_dut.vcd", ['root/testbench/correct'])
            ret, msg = cmpr.compare()
            return (ret, msg)

        ret, msg = main()
        print(msg)
        print("Ret status: {}".format(ret))
        sys.exit(0 if ret is True else 1)
    - name: testbench.v
      content: |-
        module testbench();
            reg [3:0] s0;
            reg [3:0] s1;
            reg [3:0] s2;
            reg rst;
            reg clk;
            wire [3:0] t0;
            wire [3:0] t1;
            wire [3:0] t2;
            wire done;

            reg correct;
            reg faulty_value;
            top_module DUT(s0, s1, s2, rst, clk, t0, t1, t2, done);
            // http://www.referencedesigner.com/tutorials/verilog/verilog_62.php
            initial begin
                $dumpfile("out.vcd");
                // This will dump all signal, which may not be useful
                //$dumpvars;
                // dumping only this module
                //$dumpvars(1, testbench);
                // dumping only these variable
                // the first number (level) is actually useless
                $dumpvars(0, clk, rst, s0, s1, s2, t0, t1, t2, done, correct);
            end
            integer i;
            initial begin
                clk = 1; correct = 0; faulty_value = 0;
                for (i = 0; i < 14; i = i + 1) begin
                    #1 clk = ~clk;
                end
                if (t0 == 4'd5 && t1 == 4'd7 && t2 == 4'd8 && done == 1 && faulty_value == 0) begin
                    correct = 1;
                end
                #1;
            end

            always @ (*) begin
                // Test at the earliest time it claims to be finished
                if (done == 1 && (t0 != 4'd5 || t1 != 4'd7 || t2 != 4'd8)) begin
                    faulty_value <= 1;
                end
            end

            initial begin
                s0 = 8; s1 = 5; s2 = 7; rst = 1;
                #4 rst = 0;
            end
        endmodule
    - name: main.sh
      content: |-
        #!/bin/bash
        iverilog ./testcase/testbench.v ./problem/code_ref.v -o ref_run
        vvp ref_run
        mv out.vcd out_ref.vcd

        iverilog ./testcase/testbench.v ./submit/code.v -o dut_run

        if [ $? -ne 0 ]; then
          echo "CE" > possible_error.txt
          exit 1
        fi

        vvp dut_run

        if [ $? -ne 0 ]; then
          echo "CE" > possible_error.txt
          exit 1
        fi

        mv out.vcd out_dut.vcd

        python3 ./testcase/vcd_main.py         # This will compare out_ref.vcd and out_dut.vcd

        if [ $? -ne 0 ]; then
          echo "0" > score.txt
          echo "WA" > possible_error.txt
        else
          echo "10" > score.txt
          echo "NONE" > possible_error.txt
        fi

        python3 ./testcase/vcd_visualize.py    # This will output app_data.txt

  - type: SIM
    grade: 10
    testcase_files:
    - name: wavedump.py
      content: |+
        #!/usr/bin/env python3

        """
        Example signal:

        {
            'name': 'root', 
            'type': {'name': 'struct'}, 
            'children': [
                {
                    'name': 'testbench', 
                    'type': {'name': 'struct'}, 
                    'children': [
                        {
                            'name': 'x', 
                            'type': {'width': 3, 'name': 'reg'}, 
                            'data': [
                                (0, 'bx'), (1, 'b0'), (2, 'b1'), (3, 'b10'), (4, 'b11'), (5, 'b100'), (6, 'b101'), (7, 'b110'), (8, 'b111')
                            ]
                        }, 
                        {
                            'name': 'y', 
                            'type': {
                                'width': 8, 
                                'name': 'wire'
                            }, 
                            'data': [
                                (0, 'bx'), (1, 'b1'), (2, 'b10'), (3, 'b100'), (4, 'b1000'), (5, 'b10000'), (6, 'b100000'), (7, 'b1000000'), (8, 'b10000000')
                            ]
                        }
                    ]
                }
            ]
        }

        """


        from pyDigitalWaveTools.vcd.parser import VcdParser

        class VcdSignalTraversalError(Exception):
            pass

        class VcdSignalComparationError(Exception):
            pass

        def find_signal_inst(data_obj, signal_path):
            components = signal_path.split("/")
            cur = data_obj
            for i in range(0, len(components) - 1):
                if cur['name'] != components[i]:
                    raise VcdSignalTraversalError("{} mismatch with {} while traversing {}".format(
                        cur['name'], components[i], signal_path))

                if not 'children' in cur.keys():
                    raise VcdSignalTraversalError("{} have no data k-v pair while traversing {}".format(
                        cur['name'], signal_path))

                found = False
                for child in cur['children']:
                    if child['name'] == components[i+1]:
                        found = True
                        cur = child
                        break

                if not found:
                    raise VcdSignalTraversalError("{} have no children called {} while traversing {}".format(
                        cur['name'], components[i+1], signal_path))

            if cur['name'] != components[-1]:
                raise VcdSignalTraversalError("{} mismatch with {} while traversing {}".format(
                    cur['name'], components[-1], signal_path))

            return cur

        class VcdComparator:

            def compare_signals(self, ref, ud):
                # compare width
                if ref['type']['width'] != ud['type']['width']:
                    raise VcdSignalComparationError("Signal {} have different width between ref ({}) and ud ({})".format(
                        ref['name'], ref['type']['width'], ud['type']['width']))

                # No need to compare sigType (reg/wire.. anything else?)

                # signal comparation
                # TODO: support for different types ('b0' with 'b000' or 'd0' or something...)
                
                # Since value change dump theoretically only generates data when changes
                # so direct diffing should work
                for i, val in enumerate(ref['data']):
                    if ud['data'][i] != val:
                        raise VcdSignalComparationError("Signal {} have difference on time {} (ref={}, ud={})".format(
                            ref['name'], val[0], val, ud['data'][i]))

            def dump_hierarchy(self, data_obj):
                # TODO: only dump names
                print(data_obj.toJSON())

            def __init__(self, vcd_ref, vcd_ut, signal_names):
                """Initialize signals for comparation
                vcd_ref: the reference vcd file
                vcd_ut: the vcd file under test
                signal_names: the signal for comparation, uses "/" to express hierarchy.
                        and the top module name shall also be included.
                """

                with open(vcd_ref) as vcd_ref_file:
                    vcd = VcdParser()
                    vcd.parse(vcd_ref_file)
                    self.data_ref = vcd.scope.toJson()
                    print(self.data_ref)

                with open(vcd_ut) as vcd_ut_file:
                    vcd_ut = VcdParser()
                    vcd_ut.parse(vcd_ut_file)
                    self.data_ut = vcd_ut.scope.toJson()
                    print(self.data_ut)

                # find all signals
                self.signals_ref = [find_signal_inst(self.data_ref, i) for i in signal_names]
                self.signals_ut = [find_signal_inst(self.data_ut, i) for i in signal_names]

            def compare(self):
                try:
                    # compare all signals
                    for i in range(0, len(self.signals_ref)):
                        self.compare_signals(self.signals_ref[i], self.signals_ut[i])
                    return (True, "No error")
                except VcdSignalComparationError as e:
                    return (False, "{}".format(e))

        import json

        class VcdSignalValueParseError(Exception):
            pass

        class VcdConverter:

            def __init__(self, data_vcd):
                self.output = {'signal': []}
                self.data_vcd = data_vcd
                self.global_time_max = 0

            def emitWaveDict(self):
                return self.output

            def mergeWaveDict(self, wdict):
                self.output['signal'] += wdict['signal']

            def emitWaveJson(self):
                return json.dumps(self.output)

            def parseValue(self, val_str):
                """ Note: b111xx1 -> x """
                if val_str[0] == "b":
                    if val_str.find("x") != -1:
                        return "x"
                    return int(val_str[1:], base=2)
                elif len(val_str) == 1:
                    if val_str[0] == "x":
                        return "x"
                    else:
                        return int(val_str, base=2)
                else:
                    raise VcdSignalValueParseError("Unknown value type")

            def toBinRepr(self, val, width):
                if val == 'x':
                    return 'x' * width

                striped = bin(val)[2:]
                assert(width >= len(striped))
                return "0" * (width - len(striped)) + striped

            def addToWaveJsonSeparate(self, signal_names, prefix=""):
                # find common time_max
                time_max = self.global_time_max
                for signal_name in signal_names:
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)
                    time_max = max(time_max, sig_inst['data'][-1][0])
                
                self.global_time_max = time_max

                for signal_name in signal_names:
                    sig_jsons = []
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)

                    width = sig_inst['type']['width']
                    # decompose
                    for i in range(0, width):
                        sig_jsons.append({})
                        sig_jsons[i]['name'] = prefix + sig_inst['name'] + "[" + str(i) + "]"

                    local_time_max = sig_inst['data'][-1][0]
                    waves = ["" for i in range(0, width)]
                    cur_step_ptr = 0

                    # "x" or int or "SOME.."
                    cur_wave = "SOMETHING_NEVER_HAPPEN"

                    # TODO: Avoid multiple transitions at same timestep
                    for i in range(0, local_time_max + 1):
                        if sig_inst['data'][cur_step_ptr][0] > i:
                            # maintain current value
                            for i in range(0, width):
                                waves[i] += "."
                        else:
                            new_wave = self.parseValue(sig_inst['data'][cur_step_ptr][1])
                            if new_wave == cur_wave:
                                waves[i] += "."
                            else:
                                # do bitwise comparation
                                if cur_wave == "SOMETHING_NEVER_HAPPEN":
                                    # new_wave_bin[0] is MSB
                                    new_wave_bin = self.toBinRepr(new_wave, width)
                                    for i in range(0, width):
                                        waves[i] += new_wave_bin[::-1][i]
                                else:
                                    cur_wave_bin = self.toBinRepr(cur_wave, width)
                                    new_wave_bin = self.toBinRepr(new_wave, width)

                                    for i in range(0, width):
                                        old = cur_wave_bin[::-1][i]
                                        new = new_wave_bin[::-1][i]
                                        if old != new:
                                            waves[i] += new
                                        else:
                                            waves[i] += '.'

                                cur_wave = new_wave

                            cur_step_ptr += 1

                    for i in range(local_time_max, time_max + 1):
                        for i in range(0, width):
                            waves[i] += "."

                    for i in range(0, width):
                        sig_jsons[i]['wave'] = waves[i]

                    self.output['signal'] += sig_jsons

            def addToWaveJsonAggregated(self, signal_names, prefix=""):
                """ Aggregated view, which uses '=' on every timeslice. """
                # find common time_max
                time_max = self.global_time_max
                for signal_name in signal_names:
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)
                    time_max = max(time_max, sig_inst['data'][-1][0])

                self.global_time_max = time_max

                for signal_name in signal_names:
                    sig_json = {}
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)
                    sig_json['name'] = prefix + sig_inst['name']

                    # [0, time_max]
                    local_time_max = sig_inst['data'][-1][0]
                    wave = ""
                    cur_step_ptr = 0
                    cur_wave = "SOMETHING_NEVER_HAPPEN"
                    data = []

                    # TODO: Avoid multiple transitions at same timestep
                    for i in range(0, local_time_max + 1):
                        if sig_inst['data'][cur_step_ptr][0] > i:
                            # maintain current value
                            wave += "."
                        else:
                            new_wave = self.parseValue(sig_inst['data'][cur_step_ptr][1])
                            if new_wave == cur_wave:
                                wave += "."
                            else:
                                wave += "="
                                data.append(new_wave)
                                cur_wave = new_wave

                            cur_step_ptr += 1

                    for i in range(local_time_max, time_max + 1):
                        wave += "."

                    sig_json['wave'] = wave
                    sig_json['data'] = data

                    self.output['signal'].append(sig_json)


        if __name__ == "__main__":
            sample_vcd = {'name': 'root', 'type': {'name': 'struct'}, 'children': [{'name': 'testbench', 'type': {'name': 'struct'}, 'children': [{'name': 'x', 'type': {'width': 3, 'name': 'reg'}, 'data': [(0, 'bx'), (1, 'b0'), (2, 'b1'), (3, 'b10'), (4, 'b11'), (5, 'b100'), (6, 'b101'), (7, 'b110'), (8, 'b111')]}, {'name': 'y', 'type': {'width': 8, 'name': 'wire'}, 'data': [(0, 'bx'), (1, 'b1'), (2, 'b1x'), (3, 'b100'), (4, 'b1000'), (5, 'b10000'), (6, 'b100000'), (7, 'b1000000'), (8, 'b10000000')]}]}]}
            sample_vcd2 = {'name': 'root', 'type': {'name': 'struct'}, 'children': [{'name': 'testbench', 'type': {'name': 'struct'}, 'children': [{'name': 'a', 'type': {'width': 1, 'name': 'reg'}, 'data': [(0, 'x'), (1, '0'), (2, '1'), (3, '0'), (4, '1')]}, {'name': 'b', 'type': {'width': 1, 'name': 'reg'}, 'data': [(0, 'x'), (1, '0'), (3, '1')]}, {'name': 'out', 'type': {'width': 1, 'name': 'wire'}, 'data': [(0, 'x'), (1, '1'), (2, '0'), (4, '1')]}]}]}
            vc = VcdConverter(sample_vcd)
            vc.addToWaveJsonSeparate(['root/testbench/x', 'root/testbench/y'], "mysig_")
            vc.addToWaveJsonAggregated(['root/testbench/x', 'root/testbench/y'], "mysig_")
            print(vc.emitWaveJson())

            vc2 = VcdConverter(sample_vcd2)
            vc2.addToWaveJsonSeparate(['root/testbench/a', 'root/testbench/b', 'root/testbench/out'], "mysig_")
            vc2.addToWaveJsonAggregated(['root/testbench/a', 'root/testbench/b', 'root/testbench/out'], "mysig_")
            print(vc2.emitWaveJson())

    - name: vcd_visualize.py
      content: |
        #!/usr/bin/env python3
        import sys

        def main():
            from pyDigitalWaveTools.vcd.parser import VcdParser
            from wavedump import VcdConverter

            with open("./out_ref.vcd") as vcd_ref_file:
                vcd = VcdParser()
                vcd.parse(vcd_ref_file)
                data_ref = vcd.scope.toJson()

            with open("./out_dut.vcd") as vcd_dut_file:
                vcd = VcdParser()
                vcd.parse(vcd_dut_file)
                data_dut = vcd.scope.toJson()

            vc_ref = VcdConverter(data_ref)
            vc_ref.addToWaveJsonSeparate([
                'root/testbench/clk',
                'root/testbench/rst',
                'root/testbench/done',
                'root/testbench/correct'
            ], "reference_")
            vc_ref.addToWaveJsonAggregated([
                'root/testbench/s0',
                'root/testbench/s1',
                'root/testbench/s2',
                'root/testbench/t0',
                'root/testbench/t1',
                'root/testbench/t2']
                , "reference_")

            vc_dut = VcdConverter(data_dut)
            vc_dut.addToWaveJsonSeparate([
                'root/testbench/clk',
                'root/testbench/rst',
                'root/testbench/done',
                'root/testbench/correct'
            ], "your_")
            vc_dut.addToWaveJsonAggregated([
                'root/testbench/s0',
                'root/testbench/s1',
                'root/testbench/s2',
                'root/testbench/t0',
                'root/testbench/t1',
                'root/testbench/t2']
                , "your_")

            vc_ref.mergeWaveDict(vc_dut.emitWaveDict())
            out = vc_ref.emitWaveJson()

            with open("./appdata.txt", "w") as f:
                f.write(out)

        main()

    - name: vcd_main.py
      content: |
        #!/usr/bin/env python3
        import sys

        def main():

            from wavedump import VcdComparator
            cmpr = VcdComparator("./out_ref.vcd", "./out_dut.vcd", ['root/testbench/correct'])
            ret, msg = cmpr.compare()
            return (ret, msg)

        ret, msg = main()
        print(msg)
        print("Ret status: {}".format(ret))
        sys.exit(0 if ret is True else 1)
    - name: testbench.v
      content: |-
        module testbench();
            reg [3:0] s0;
            reg [3:0] s1;
            reg [3:0] s2;
            reg rst;
            reg clk;
            wire [3:0] t0;
            wire [3:0] t1;
            wire [3:0] t2;
            wire done;

            reg correct;
            reg faulty_value;
            top_module DUT(s0, s1, s2, rst, clk, t0, t1, t2, done);
            // http://www.referencedesigner.com/tutorials/verilog/verilog_62.php
            initial begin
                $dumpfile("out.vcd");
                // This will dump all signal, which may not be useful
                //$dumpvars;
                // dumping only this module
                //$dumpvars(1, testbench);
                // dumping only these variable
                // the first number (level) is actually useless
                $dumpvars(0, clk, rst, s0, s1, s2, t0, t1, t2, done, correct);
            end
            integer i;
            initial begin
                clk = 1; correct = 0; faulty_value = 0;
                for (i = 0; i < 14; i = i + 1) begin
                    #1 clk = ~clk;
                end
                if (t0 == 4'd5 && t1 == 4'd7 && t2 == 4'd8 && done == 1 && faulty_value == 0) begin
                    correct = 1;
                end
                #1;
            end

            always @ (*) begin
                // Test at the earliest time it claims to be finished
                if (done == 1 && (t0 != 4'd5 || t1 != 4'd7 || t2 != 4'd8)) begin
                    faulty_value <= 1;
                end
            end

            initial begin
                s0 = 7; s1 = 8; s2 = 5; rst = 1;
                #4 rst = 0;
            end
        endmodule
    - name: main.sh
      content: |-
        #!/bin/bash
        iverilog ./testcase/testbench.v ./problem/code_ref.v -o ref_run
        vvp ref_run
        mv out.vcd out_ref.vcd

        iverilog ./testcase/testbench.v ./submit/code.v -o dut_run

        if [ $? -ne 0 ]; then
          echo "CE" > possible_error.txt
          exit 1
        fi

        vvp dut_run

        if [ $? -ne 0 ]; then
          echo "CE" > possible_error.txt
          exit 1
        fi

        mv out.vcd out_dut.vcd

        python3 ./testcase/vcd_main.py         # This will compare out_ref.vcd and out_dut.vcd

        if [ $? -ne 0 ]; then
          echo "0" > score.txt
          echo "WA" > possible_error.txt
        else
          echo "10" > score.txt
          echo "NONE" > possible_error.txt
        fi

        python3 ./testcase/vcd_visualize.py    # This will output app_data.txt

  - type: SYNTHSIM
    grade: 10
    testcase_files:
    - name: wavedump.py
      content: |+
        #!/usr/bin/env python3

        """
        Example signal:

        {
            'name': 'root', 
            'type': {'name': 'struct'}, 
            'children': [
                {
                    'name': 'testbench', 
                    'type': {'name': 'struct'}, 
                    'children': [
                        {
                            'name': 'x', 
                            'type': {'width': 3, 'name': 'reg'}, 
                            'data': [
                                (0, 'bx'), (1, 'b0'), (2, 'b1'), (3, 'b10'), (4, 'b11'), (5, 'b100'), (6, 'b101'), (7, 'b110'), (8, 'b111')
                            ]
                        }, 
                        {
                            'name': 'y', 
                            'type': {
                                'width': 8, 
                                'name': 'wire'
                            }, 
                            'data': [
                                (0, 'bx'), (1, 'b1'), (2, 'b10'), (3, 'b100'), (4, 'b1000'), (5, 'b10000'), (6, 'b100000'), (7, 'b1000000'), (8, 'b10000000')
                            ]
                        }
                    ]
                }
            ]
        }

        """


        from pyDigitalWaveTools.vcd.parser import VcdParser

        class VcdSignalTraversalError(Exception):
            pass

        class VcdSignalComparationError(Exception):
            pass

        def find_signal_inst(data_obj, signal_path):
            components = signal_path.split("/")
            cur = data_obj
            for i in range(0, len(components) - 1):
                if cur['name'] != components[i]:
                    raise VcdSignalTraversalError("{} mismatch with {} while traversing {}".format(
                        cur['name'], components[i], signal_path))

                if not 'children' in cur.keys():
                    raise VcdSignalTraversalError("{} have no data k-v pair while traversing {}".format(
                        cur['name'], signal_path))

                found = False
                for child in cur['children']:
                    if child['name'] == components[i+1]:
                        found = True
                        cur = child
                        break

                if not found:
                    raise VcdSignalTraversalError("{} have no children called {} while traversing {}".format(
                        cur['name'], components[i+1], signal_path))

            if cur['name'] != components[-1]:
                raise VcdSignalTraversalError("{} mismatch with {} while traversing {}".format(
                    cur['name'], components[-1], signal_path))

            return cur

        class VcdComparator:

            def compare_signals(self, ref, ud):
                # compare width
                if ref['type']['width'] != ud['type']['width']:
                    raise VcdSignalComparationError("Signal {} have different width between ref ({}) and ud ({})".format(
                        ref['name'], ref['type']['width'], ud['type']['width']))

                # No need to compare sigType (reg/wire.. anything else?)

                # signal comparation
                # TODO: support for different types ('b0' with 'b000' or 'd0' or something...)
                
                # Since value change dump theoretically only generates data when changes
                # so direct diffing should work
                for i, val in enumerate(ref['data']):
                    if ud['data'][i] != val:
                        raise VcdSignalComparationError("Signal {} have difference on time {} (ref={}, ud={})".format(
                            ref['name'], val[0], val, ud['data'][i]))

            def dump_hierarchy(self, data_obj):
                # TODO: only dump names
                print(data_obj.toJSON())

            def __init__(self, vcd_ref, vcd_ut, signal_names):
                """Initialize signals for comparation
                vcd_ref: the reference vcd file
                vcd_ut: the vcd file under test
                signal_names: the signal for comparation, uses "/" to express hierarchy.
                        and the top module name shall also be included.
                """

                with open(vcd_ref) as vcd_ref_file:
                    vcd = VcdParser()
                    vcd.parse(vcd_ref_file)
                    self.data_ref = vcd.scope.toJson()
                    print(self.data_ref)

                with open(vcd_ut) as vcd_ut_file:
                    vcd_ut = VcdParser()
                    vcd_ut.parse(vcd_ut_file)
                    self.data_ut = vcd_ut.scope.toJson()
                    print(self.data_ut)

                # find all signals
                self.signals_ref = [find_signal_inst(self.data_ref, i) for i in signal_names]
                self.signals_ut = [find_signal_inst(self.data_ut, i) for i in signal_names]

            def compare(self):
                try:
                    # compare all signals
                    for i in range(0, len(self.signals_ref)):
                        self.compare_signals(self.signals_ref[i], self.signals_ut[i])
                    return (True, "No error")
                except VcdSignalComparationError as e:
                    return (False, "{}".format(e))

        import json

        class VcdSignalValueParseError(Exception):
            pass

        class VcdConverter:

            def __init__(self, data_vcd):
                self.output = {'signal': []}
                self.data_vcd = data_vcd
                self.global_time_max = 0

            def emitWaveDict(self):
                return self.output

            def mergeWaveDict(self, wdict):
                self.output['signal'] += wdict['signal']

            def emitWaveJson(self):
                return json.dumps(self.output)

            def parseValue(self, val_str):
                """ Note: b111xx1 -> x """
                if val_str[0] == "b":
                    if val_str.find("x") != -1:
                        return "x"
                    return int(val_str[1:], base=2)
                elif len(val_str) == 1:
                    if val_str[0] == "x":
                        return "x"
                    else:
                        return int(val_str, base=2)
                else:
                    raise VcdSignalValueParseError("Unknown value type")

            def toBinRepr(self, val, width):
                if val == 'x':
                    return 'x' * width

                striped = bin(val)[2:]
                assert(width >= len(striped))
                return "0" * (width - len(striped)) + striped

            def addToWaveJsonSeparate(self, signal_names, prefix=""):
                # find common time_max
                time_max = self.global_time_max
                for signal_name in signal_names:
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)
                    time_max = max(time_max, sig_inst['data'][-1][0])
                
                self.global_time_max = time_max

                for signal_name in signal_names:
                    sig_jsons = []
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)

                    width = sig_inst['type']['width']
                    # decompose
                    for i in range(0, width):
                        sig_jsons.append({})
                        sig_jsons[i]['name'] = prefix + sig_inst['name'] + "[" + str(i) + "]"

                    local_time_max = sig_inst['data'][-1][0]
                    waves = ["" for i in range(0, width)]
                    cur_step_ptr = 0

                    # "x" or int or "SOME.."
                    cur_wave = "SOMETHING_NEVER_HAPPEN"

                    # TODO: Avoid multiple transitions at same timestep
                    for i in range(0, local_time_max + 1):
                        if sig_inst['data'][cur_step_ptr][0] > i:
                            # maintain current value
                            for i in range(0, width):
                                waves[i] += "."
                        else:
                            new_wave = self.parseValue(sig_inst['data'][cur_step_ptr][1])
                            if new_wave == cur_wave:
                                waves[i] += "."
                            else:
                                # do bitwise comparation
                                if cur_wave == "SOMETHING_NEVER_HAPPEN":
                                    # new_wave_bin[0] is MSB
                                    new_wave_bin = self.toBinRepr(new_wave, width)
                                    for i in range(0, width):
                                        waves[i] += new_wave_bin[::-1][i]
                                else:
                                    cur_wave_bin = self.toBinRepr(cur_wave, width)
                                    new_wave_bin = self.toBinRepr(new_wave, width)

                                    for i in range(0, width):
                                        old = cur_wave_bin[::-1][i]
                                        new = new_wave_bin[::-1][i]
                                        if old != new:
                                            waves[i] += new
                                        else:
                                            waves[i] += '.'

                                cur_wave = new_wave

                            cur_step_ptr += 1

                    for i in range(local_time_max, time_max + 1):
                        for i in range(0, width):
                            waves[i] += "."

                    for i in range(0, width):
                        sig_jsons[i]['wave'] = waves[i]

                    self.output['signal'] += sig_jsons

            def addToWaveJsonAggregated(self, signal_names, prefix=""):
                """ Aggregated view, which uses '=' on every timeslice. """
                # find common time_max
                time_max = self.global_time_max
                for signal_name in signal_names:
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)
                    time_max = max(time_max, sig_inst['data'][-1][0])

                self.global_time_max = time_max

                for signal_name in signal_names:
                    sig_json = {}
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)
                    sig_json['name'] = prefix + sig_inst['name']

                    # [0, time_max]
                    local_time_max = sig_inst['data'][-1][0]
                    wave = ""
                    cur_step_ptr = 0
                    cur_wave = "SOMETHING_NEVER_HAPPEN"
                    data = []

                    # TODO: Avoid multiple transitions at same timestep
                    for i in range(0, local_time_max + 1):
                        if sig_inst['data'][cur_step_ptr][0] > i:
                            # maintain current value
                            wave += "."
                        else:
                            new_wave = self.parseValue(sig_inst['data'][cur_step_ptr][1])
                            if new_wave == cur_wave:
                                wave += "."
                            else:
                                wave += "="
                                data.append(new_wave)
                                cur_wave = new_wave

                            cur_step_ptr += 1

                    for i in range(local_time_max, time_max + 1):
                        wave += "."

                    sig_json['wave'] = wave
                    sig_json['data'] = data

                    self.output['signal'].append(sig_json)


        if __name__ == "__main__":
            sample_vcd = {'name': 'root', 'type': {'name': 'struct'}, 'children': [{'name': 'testbench', 'type': {'name': 'struct'}, 'children': [{'name': 'x', 'type': {'width': 3, 'name': 'reg'}, 'data': [(0, 'bx'), (1, 'b0'), (2, 'b1'), (3, 'b10'), (4, 'b11'), (5, 'b100'), (6, 'b101'), (7, 'b110'), (8, 'b111')]}, {'name': 'y', 'type': {'width': 8, 'name': 'wire'}, 'data': [(0, 'bx'), (1, 'b1'), (2, 'b1x'), (3, 'b100'), (4, 'b1000'), (5, 'b10000'), (6, 'b100000'), (7, 'b1000000'), (8, 'b10000000')]}]}]}
            sample_vcd2 = {'name': 'root', 'type': {'name': 'struct'}, 'children': [{'name': 'testbench', 'type': {'name': 'struct'}, 'children': [{'name': 'a', 'type': {'width': 1, 'name': 'reg'}, 'data': [(0, 'x'), (1, '0'), (2, '1'), (3, '0'), (4, '1')]}, {'name': 'b', 'type': {'width': 1, 'name': 'reg'}, 'data': [(0, 'x'), (1, '0'), (3, '1')]}, {'name': 'out', 'type': {'width': 1, 'name': 'wire'}, 'data': [(0, 'x'), (1, '1'), (2, '0'), (4, '1')]}]}]}
            vc = VcdConverter(sample_vcd)
            vc.addToWaveJsonSeparate(['root/testbench/x', 'root/testbench/y'], "mysig_")
            vc.addToWaveJsonAggregated(['root/testbench/x', 'root/testbench/y'], "mysig_")
            print(vc.emitWaveJson())

            vc2 = VcdConverter(sample_vcd2)
            vc2.addToWaveJsonSeparate(['root/testbench/a', 'root/testbench/b', 'root/testbench/out'], "mysig_")
            vc2.addToWaveJsonAggregated(['root/testbench/a', 'root/testbench/b', 'root/testbench/out'], "mysig_")
            print(vc2.emitWaveJson())

    - name: vcd_visualize.py
      content: |
        #!/usr/bin/env python3
        import sys

        def main():
            from pyDigitalWaveTools.vcd.parser import VcdParser
            from wavedump import VcdConverter

            with open("./out_ref.vcd") as vcd_ref_file:
                vcd = VcdParser()
                vcd.parse(vcd_ref_file)
                data_ref = vcd.scope.toJson()

            with open("./out_dut.vcd") as vcd_dut_file:
                vcd = VcdParser()
                vcd.parse(vcd_dut_file)
                data_dut = vcd.scope.toJson()

            vc_ref = VcdConverter(data_ref)
            vc_ref.addToWaveJsonSeparate([
                'root/testbench/clk',
                'root/testbench/rst',
                'root/testbench/done',
                'root/testbench/correct'
            ], "reference_")
            vc_ref.addToWaveJsonAggregated([
                'root/testbench/s0',
                'root/testbench/s1',
                'root/testbench/s2',
                'root/testbench/t0',
                'root/testbench/t1',
                'root/testbench/t2']
                , "reference_")

            vc_dut = VcdConverter(data_dut)
            vc_dut.addToWaveJsonSeparate([
                'root/testbench/clk',
                'root/testbench/rst',
                'root/testbench/done',
                'root/testbench/correct'
            ], "your_")
            vc_dut.addToWaveJsonAggregated([
                'root/testbench/s0',
                'root/testbench/s1',
                'root/testbench/s2',
                'root/testbench/t0',
                'root/testbench/t1',
                'root/testbench/t2']
                , "your_")

            vc_ref.mergeWaveDict(vc_dut.emitWaveDict())
            out = vc_ref.emitWaveJson()

            with open("./appdata.txt", "w") as f:
                f.write(out)

        main()

    - name: vcd_main.py
      content: |
        #!/usr/bin/env python3
        import sys

        def main():

            from wavedump import VcdComparator
            cmpr = VcdComparator("./out_ref.vcd", "./out_dut.vcd", ['root/testbench/correct'])
            ret, msg = cmpr.compare()
            return (ret, msg)

        ret, msg = main()
        print(msg)
        print("Ret status: {}".format(ret))
        sys.exit(0 if ret is True else 1)
    - name: testbench.v
      content: |-
        module testbench();
            reg [3:0] s0;
            reg [3:0] s1;
            reg [3:0] s2;
            reg rst;
            reg clk;
            wire [3:0] t0;
            wire [3:0] t1;
            wire [3:0] t2;
            wire done;

            reg correct;
            reg faulty_value;
            top_module DUT(s0, s1, s2, rst, clk, t0, t1, t2, done);
            // http://www.referencedesigner.com/tutorials/verilog/verilog_62.php
            initial begin
                $dumpfile("out.vcd");
                // This will dump all signal, which may not be useful
                //$dumpvars;
                // dumping only this module
                //$dumpvars(1, testbench);
                // dumping only these variable
                // the first number (level) is actually useless
                $dumpvars(0, clk, rst, s0, s1, s2, t0, t1, t2, done, correct);
            end
            integer i;
            initial begin
                clk = 1; correct = 0; faulty_value = 0;
                for (i = 0; i < 14; i = i + 1) begin
                    #1 clk = ~clk;
                end
                if (t0 == 4'd5 && t1 == 4'd7 && t2 == 4'd8 && done == 1 && faulty_value == 0) begin
                    correct = 1;
                end
                #1;
            end

            always @ (*) begin
                // Test at the earliest time it claims to be finished
                if (done == 1 && (t0 != 4'd5 || t1 != 4'd7 || t2 != 4'd8)) begin
                    faulty_value <= 1;
                end
            end

            initial begin
                s0 = 8; s1 = 5; s2 = 7; rst = 1;
                #4 rst = 0;
            end
        endmodule
    - name: main.sh
      content: |-
        #!/bin/bash
        iverilog ./testcase/testbench.v ./problem/code_ref.v -o ref_run
        vvp ref_run
        mv out.vcd out_ref.vcd

        yosys -p "read_verilog ./submit/code.v; synth -top top_module; write_verilog code_synthed.v" -v 3
        
        if [ $? -ne 0 ]; then
          echo "CE" > possible_error.txt
          exit 1
        fi

        iverilog ./testcase/testbench.v code_synthed.v -o dut_run

        if [ $? -ne 0 ]; then
          echo "CE" > possible_error.txt
          exit 1
        fi

        vvp dut_run

        if [ $? -ne 0 ]; then
          echo "CE" > possible_error.txt
          exit 1
        fi

        mv out.vcd out_dut.vcd

        python3 ./testcase/vcd_main.py         # This will compare out_ref.vcd and out_dut.vcd

        if [ $? -ne 0 ]; then
          echo "0" > score.txt
          echo "WA" > possible_error.txt
        else
          echo "10" > score.txt
          echo "NONE" > possible_error.txt
        fi

        python3 ./testcase/vcd_visualize.py    # This will output app_data.txt
