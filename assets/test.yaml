problems:
- name: '123'
  description: "wire\u662FVerilog\u7684\u5173\u952E\u5B57\uFF0C\u7528\u4E8E\u8868\u5F81\
    \u4FE1\u53F7\u7C7B\u578B\u7684\uFF0C\u5176\u542B\u4E49\u662F\u7EBF\u7F51\uFF0C\
    wire\u53EF\u7406\u89E3\u4E3A\u7269\u7406\u8FDE\u7EBF\uFF0C\u4F46\u53C8\u6709\u6240\
    \u4E0D\u540C\uFF0C\u56E0\u4E3Averilog\u4E2D\u7684wire\u662F\u6709\u65B9\u5411\u7684\
    \uFF0C\u4F8B\u5982\u8BBE\u8BA1\u4E00\u6A21\u5757\uFF0C\u6A21\u5757\u540D\u547D\
    \u540D\u4E3Atop\\_module\uFF0C\u8F93\u5165\u4FE1\u53F7\u540D\u4E3Ain\uFF0C\u8F93\
    \u51FA\u4FE1\u53F7\u540D\u4E3Aout\uFF0C\u4F7Fin\u4E0Eout\u76F4\u8FDE\uFF0C\u5982\
    \u4E0B\u56FE\u6240\u793A\uFF1A\r\n![](data:image/png;base64,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)\r\
    \n\u8BF7\u4F7F\u7528assign\u8BED\u53E5\u5C06\u4EE3\u7801\u8865\u5145\u5B8C\u6574\
    \uFF0C\u4F7F\u5176\u5B9E\u73B0\u4E0A\u8FF0\u7535\u8DEF\u56FE\u7684\u529F\u80FD"
  description_input: "\u8F93\u5165a,b,sel\u90FD\u4E3A1bit"
  description_output: "test"
  app_data: "{\"signal\": [\r\n  {\"name\": \"sel\", \"wave\": \"0...1...\"},\r\n\
    \  {\"name\": \"a\", \"wave\": \"0.1.0.1.\"},\r\n  {\"name\": \"b\", \"wave\"\
    :\"01010101\"},\r\n  {\"name\": \"out\", \"wave\": \"0.1.0101\"}\r\n]}"
  judge_files:
  - name: code_ref.v
    content: "module top_module(\n      input sel,\n      input a,\n      input b,\n\
      \      output reg out\n  );\n  \n  always @(*)\n  if(sel)\n    out = b;\n  else\n\
      \    out = a;\n\nendmodule"
  template_code_file:
    name: template_code.v
    content: |-
      module top_module(
            input sel,
            input a,
            input b,
            output out
        );
        // Write your code here
      endmodule
  testcases:
  - type: SIM
    grade: 10
    testcase_files:
    - name: vcd_main.py
      content: "#!/usr/bin/env python3\nimport sys\n\ndef main():\n\n    from wavedump\
        \ import VcdComparator\n    from pyverilog.dataflow.dataflow_analyzer import\
        \ VerilogDataflowAnalyzer\n\n    filelist = ['./problem/code_ref.v']\n\n \
        \   topmodule = 'top_module'\n    noreorder = False\n    nobind = False\n\
        \    include = None\n    define = None\n\n    analyzer = VerilogDataflowAnalyzer(filelist,\
        \ topmodule,\n                                      noreorder=noreorder,\n\
        \                                      nobind=nobind,\n                  \
        \                    preprocess_include=include,\n                       \
        \               preprocess_define=define)\n\n    analyzer.generate()\n   \
        \ terms = analyzer.getTerms()\n\n    compare_list = []\n    for tk, tv in\
        \ sorted(terms.items(), key=lambda x:str(x[0])):\n      if 'Input' in tv.termtype\
        \ or 'Output' in tv.termtype: \n        compare_list.append('root/testbench/'+str(tk.scopechain[1]))\n\
        \n    print('compare list')\n    print(compare_list)\n    cmpr = VcdComparator(\"\
        ./out_ref.vcd\", \"./out_code.vcd\", compare_list)\n    ret, msg = cmpr.compare()\n\
        \    return (ret, msg)\n\nret, msg = main()\nprint(msg)\nprint(\"Ret status:\
        \ {}\".format(ret))\nsys.exit(0 if ret is True else 1)\n"
    - name: testbench.v
      content: |2

        module testbench();
            reg sel;
            reg a;
            reg b;
            wire out;
            top_module MUX(sel, a, b, out);

            // http://www.referencedesigner.com/tutorials/verilog/verilog_62.php
            initial begin
                $dumpfile("out.vcd");
                // This will dump all signal, which may not be useful
                //$dumpvars;

                // dumping only this module
                //$dumpvars(1, testbench);

                // dumping only these variable
                // the first number (level) is actually useless
                $dumpvars(0, sel, a, b, out);
            end

            integer i;
            initial begin
                #1 sel = 0; a = 0; b = 0;
                #1 a = 1; b = 0;
                #1 a = 1; b = 1;
                #1 a = 0; b = 1;
                #1 sel = 1; a = 0; b = 0;
                #1 a = 1; b = 0;
                #1 a = 1; b = 1;
                #1 a = 0; b = 1;
            end

        endmodule
    - name: vcd_visualize.py
      content: |
        #!/usr/bin/env python3
        import sys

        def main():
            from pyDigitalWaveTools.vcd.parser import VcdParser
            from wavedump import VcdConverter
            from pyverilog.dataflow.dataflow_analyzer import VerilogDataflowAnalyzer

            filelist = ['./problem/code_ref.v']

            topmodule = 'top_module'
            noreorder = False
            nobind = False
            include = None
            define = None

            analyzer = VerilogDataflowAnalyzer(filelist, topmodule,
                                              noreorder=noreorder,
                                              nobind=nobind,
                                              preprocess_include=include,
                                              preprocess_define=define)

            analyzer.generate()
            terms = analyzer.getTerms()

            input_list = []
            output_list = []
            compare_list = []

            for tk, tv in sorted(terms.items(), key=lambda x:str(x[0])):
              if 'Input' in tv.termtype:
                input_list.append('root/testbench/'+str(tk.scopechain[1]))

              if 'Output' in tv.termtype:
                output_list.append('root/testbench/'+str(tk.scopechain[1]))
                compare_list.append(str(tk.scopechain[1]))

            with open("./out_ref.vcd") as vcd_ref_file:
                vcd = VcdParser()
                vcd.parse(vcd_ref_file)
                data_ref = vcd.scope.toJson()

            with open("./out_code.vcd") as vcd_dut_file:
                vcd = VcdParser()
                vcd.parse(vcd_dut_file)
                data_dut = vcd.scope.toJson()

            vc_ref = VcdConverter(data_ref)
            time = vc_ref.addToWaveJsonSeparate(signal_names=input_list+output_list, prefix = "reference_")

            vc_dut = VcdConverter(data_dut)
            vc_dut.addToWaveJsonSeparate_modify(signal_names=output_list, time_max=time,prefix= "your_")

            vc_ref.mergeWaveDict(vc_dut.emitWaveDict())

            vc_ref.addCompare(compare_list,"your_","reference_",1)

            out = vc_ref.emitWaveJson()

            with open("./appdata.txt", "w") as f:
                f.write(out)

        main()
    - name: main.sh
      content: |-
        #!/bin/bash
        iverilog ./testcase/testbench.v ./problem/code_ref.v -o ref_run
        vvp ref_run
        mv out.vcd out_ref.vcd

        iverilog ./testcase/testbench.v ./submit/code.v -o code_run

        if [ $? -ne 0 ]; then
          echo "CE" > possible_error.txt
          exit 1
        fi

        vvp code_run

        if [ $? -ne 0 ]; then
          echo "CE" > possible_error.txt
          exit 1
        fi

        mv out.vcd out_code.vcd

        python3 ./testcase/vcd_main.py         # This will compare out_ref.vcd and out_code.vcd

        if [ $? -ne 0 ]; then
          echo "0" > score.txt
          echo "WA" > possible_error.txt
        else
          echo "10" > score.txt
          echo "NONE" > possible_error.txt
        fi

        python3 ./testcase/vcd_visualize.py    # This will output app_data.txt
    - name: wavedump.py
      content: |-
        #!/usr/bin/env python3

        """
        Example signal:

        {
            'name': 'root', 
            'type': {'name': 'struct'}, 
            'children': [
                {
                    'name': 'testbench', 
                    'type': {'name': 'struct'}, 
                    'children': [
                        {
                            'name': 'x', 
                            'type': {'width': 3, 'name': 'reg'}, 
                            'data': [
                                (0, 'bx'), (1, 'b0'), (2, 'b1'), (3, 'b10'), (4, 'b11'), (5, 'b100'), (6, 'b101'), (7, 'b110'), (8, 'b111')
                            ]
                        }, 
                        {
                            'name': 'y', 
                            'type': {
                                'width': 8, 
                                'name': 'wire'
                            }, 
                            'data': [
                                (0, 'bx'), (1, 'b1'), (2, 'b10'), (3, 'b100'), (4, 'b1000'), (5, 'b10000'), (6, 'b100000'), (7, 'b1000000'), (8, 'b10000000')
                            ]
                        }
                    ]
                }
            ]
        }

        """


        from pyDigitalWaveTools.vcd.parser import VcdParser

        class VcdSignalTraversalError(Exception):
            pass

        class VcdSignalComparationError(Exception):
            pass

        def find_signal_inst(data_obj, signal_path):
            components = signal_path.split("/")
            cur = data_obj
            for i in range(0, len(components) - 1):
                if cur['name'] != components[i]:
                    raise VcdSignalTraversalError("{} mismatch with {} while traversing {}".format(
                        cur['name'], components[i], signal_path))

                if not 'children' in cur.keys():
                    raise VcdSignalTraversalError("{} have no data k-v pair while traversing {}".format(
                        cur['name'], signal_path))

                found = False
                for child in cur['children']:
                    if child['name'] == components[i+1]:
                        found = True
                        cur = child
                        break

                if not found:
                    raise VcdSignalTraversalError("{} have no children called {} while traversing {}".format(
                        cur['name'], components[i+1], signal_path))

            if cur['name'] != components[-1]:
                raise VcdSignalTraversalError("{} mismatch with {} while traversing {}".format(
                    cur['name'], components[-1], signal_path))

            return cur

        class VcdComparator:

            def compare_signals(self, ref, ud):
                # compare width
                if ref['type']['width'] != ud['type']['width']:
                    raise VcdSignalComparationError("Signal {} have different width between ref ({}) and ud ({})".format(
                        ref['name'], ref['type']['width'], ud['type']['width']))

                # No need to compare sigType (reg/wire.. anything else?)

                # signal comparation
                # TODO: support for different types ('b0' with 'b000' or 'd0' or something...)
                
                # Since value change dump theoretically only generates data when changes
                # so direct diffing should work
                index_ref = 0
                index_ud = 0
                time1 = 0
                time2 = 0
                val1 = ref['data'][0][1]
                val2 = ud['data'][0][1]

                while (index_ref+1) <= len(ref['data']) and (index_ud+1) <= len(ud['data']):
                    time1 = ref['data'][index_ref][0]
                    time2 = ud['data'][index_ud][0]
                    if time1 < time2:
                        val1 = ref['data'][index_ref][1]
                    elif time1 > time2:
                        val2 = ud['data'][index_ud][1]
                    else:
                        val1 = ref['data'][index_ref][1]
                        val2 = ud['data'][index_ud][1]

                    if val1 != val2:
                        raise VcdSignalComparationError("Signal {} have difference on time {} (ref={}, ud={})".format(
                            ref['name'], time1, ref['data'][index_ref], ud['data'][index_ud]))

                    if time1 < time2:
                        index_ref += 1
                    elif time1 == time2:
                        index_ref += 1
                        index_ud += 1
                    else:
                        index_ud += 1

                while (index_ref+1) <= len(ref['data']):
                    time1 = ref['data'][index_ref][0]
                    val1= ref['data'][index_ref][1]
                    if val1 != val2:
                        raise VcdSignalComparationError("Signal {} have difference on time {} (ref={}, ud={})".format(
                            ref['name'], time1, ref['data'][index_ref], ud['data'][index_ud]))
                    index_ref += 1
                    
                while (index_ud+1) <= len(ud['data']):
                    time2 = ud['data'][index_ud][0]
                    val2 = ud['data'][index_ud][1]
                    if val1 != val2:
                        raise VcdSignalComparationError("Signal {} have difference on time {} (ref={}, ud={})".format(
                            ref['name'], time2, ref['data'][index_ref], ud['data'][index_ud]))
                    index_ud += 1
                


            def dump_hierarchy(self, data_obj):
                # TODO: only dump names
                print(data_obj.toJSON())

            def __init__(self, vcd_ref, vcd_ut, signal_names):
                """Initialize signals for comparation
                vcd_ref: the reference vcd file
                vcd_ut: the vcd file under test
                signal_names: the signal for comparation, uses "/" to express hierarchy.
                        and the top module name shall also be included.
                """

                with open(vcd_ref) as vcd_ref_file:
                    vcd = VcdParser()
                    vcd.parse(vcd_ref_file)
                    self.data_ref = vcd.scope.toJson()
                    print(self.data_ref)

                with open(vcd_ut) as vcd_ut_file:
                    vcd_ut = VcdParser()
                    vcd_ut.parse(vcd_ut_file)
                    self.data_ut = vcd_ut.scope.toJson()
                    print(self.data_ut)

                # find all signals
                self.signals_ref = [find_signal_inst(self.data_ref, i) for i in signal_names]
                self.signals_ut = [find_signal_inst(self.data_ut, i) for i in signal_names]

            def compare(self):
                try:
                    # compare all signals
                    for i in range(0, len(self.signals_ref)):
                        if len(self.signals_ref[i]) == len(self.signals_ut[i]):
                            self.compare_signals(self.signals_ref[i], self.signals_ut[i])
                        else:
                            raise VcdSignalComparationError("Signal {} have different hierarchy depth between ref ({}) and ud ({})".format(
                                self.signals_ref[i]['name'], len(self.signals_ref[i]), len(self.signals_ut[i])))
                    return (True, "No error")
                except VcdSignalComparationError as e:
                    return (False, "{}".format(e))

        import json

        class VcdSignalValueParseError(Exception):
            pass

        class VcdConverter:

            def __init__(self, data_vcd):
                self.output = {'signal': []}
                self.data_vcd = data_vcd

            def emitWaveDict(self):
                return self.output

            def mergeWaveDict(self, wdict):
                self.output['signal'] += wdict['signal']

            def emitWaveJson(self):
                return json.dumps(self.output)

            def parseValue(self, val_str):
                """ Note: b111xx1 -> x """
                if val_str[0] == "b":
                    if val_str.find("x") != -1:
                        return "x"
                    return int(val_str[1:], base=2)
                elif len(val_str) == 1:
                    if val_str[0] == "x":
                        return "x"
                    else:
                        return int(val_str, base=2)
                else:
                    raise VcdSignalValueParseError("Unknown value type")

            def toBinRepr(self, val, width):
                if val == 'x':
                    return 'x' * width

                striped = bin(val)[2:]
                assert(width >= len(striped))
                return "0" * (width - len(striped)) + striped

            def addToWaveJsonSeparate(self, signal_names, prefix=""):
                # find common time_max
                time_max = 0
                for signal_name in signal_names:
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)
                    time_max = max(time_max, sig_inst['data'][-1][0])

                for signal_name in signal_names:
                    sig_jsons = []
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)


                    width = sig_inst['type']['width']
                    # decompose
                    for i in range(0, width):
                        sig_jsons.append({})
                        sig_jsons[i]['name'] = prefix + sig_inst['name'] + "[" + str(i) + "]"

                    local_time_max = sig_inst['data'][-1][0]
                    waves = ["" for i in range(0, width)]
                    cur_step_ptr = 0

                    # "x" or int or "SOME.."
                    cur_wave = "SOMETHING_NEVER_HAPPEN"

                    # TODO: Avoid multiple transitions at same timestep
                    for i in range(0, local_time_max + 1):
                        if sig_inst['data'][cur_step_ptr][0] > i:
                            # maintain current value
                            for i in range(0, width):
                                waves[i] += "."
                        else:
                            new_wave = self.parseValue(sig_inst['data'][cur_step_ptr][1])
                            if new_wave == cur_wave:
                                for i in range(0, width):
                                    waves[i] += "."
                            else:
                                # do bitwise comparation
                                if cur_wave == "SOMETHING_NEVER_HAPPEN":
                                    # new_wave_bin[0] is MSB
                                    new_wave_bin = self.toBinRepr(new_wave, width)
                                    for i in range(0, width):
                                        waves[i] += new_wave_bin[::-1][i]
                                else:
                                    cur_wave_bin = self.toBinRepr(cur_wave, width)
                                    new_wave_bin = self.toBinRepr(new_wave, width)

                                    for i in range(0, width):
                                        old = cur_wave_bin[::-1][i]
                                        new = new_wave_bin[::-1][i]
                                        if old != new:
                                            waves[i] += new
                                        else:
                                            waves[i] += '.'

                                cur_wave = new_wave

                            cur_step_ptr += 1

                    for i in range(local_time_max, time_max + 1):
                        for i in range(0, width):
                            waves[i] += "."

                    for i in range(0, width):
                        sig_jsons[i]['wave'] = waves[i]


                    self.output['signal'] += sig_jsons
              
                return time_max



            def addToWaveJsonSeparate_modify(self, signal_names, time_max, prefix=""):
                # find common time_max
                time_max = time_max

                for signal_name in signal_names:
                    sig_jsons = []
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)


                    width = sig_inst['type']['width']
                    # decompose
                    for i in range(0, width):
                        sig_jsons.append({})
                        sig_jsons[i]['name'] = prefix + sig_inst['name'] + "[" + str(i) + "]"

                    local_time_max = sig_inst['data'][-1][0]
                    waves = ["" for i in range(0, width)]
                    cur_step_ptr = 0

                    # "x" or int or "SOME.."
                    cur_wave = "SOMETHING_NEVER_HAPPEN"

                    # TODO: Avoid multiple transitions at same timestep
                    for i in range(0, local_time_max + 1):
                        if sig_inst['data'][cur_step_ptr][0] > i:
                            # maintain current value
                            for i in range(0, width):
                                waves[i] += "."
                        else:
                            new_wave = self.parseValue(sig_inst['data'][cur_step_ptr][1])
                            if new_wave == cur_wave:
                                for i in range(0, width):
                                    waves[i] += "."
                            else:
                                # do bitwise comparation
                                if cur_wave == "SOMETHING_NEVER_HAPPEN":
                                    # new_wave_bin[0] is MSB
                                    new_wave_bin = self.toBinRepr(new_wave, width)
                                    for i in range(0, width):
                                        waves[i] += new_wave_bin[::-1][i]
                                else:
                                    cur_wave_bin = self.toBinRepr(cur_wave, width)
                                    new_wave_bin = self.toBinRepr(new_wave, width)

                                    for i in range(0, width):
                                        old = cur_wave_bin[::-1][i]
                                        new = new_wave_bin[::-1][i]
                                        if old != new:
                                            waves[i] += new
                                        else:
                                            waves[i] += '.'

                                cur_wave = new_wave

                            cur_step_ptr += 1

                    for i in range(local_time_max, time_max + 1):
                        for i in range(0, width):
                            waves[i] += "."

                    for i in range(0, width):
                        sig_jsons[i]['wave'] = waves[i]


                    self.output['signal'] += sig_jsons
              

            def addToWaveJsonAggregated(self, signal_names, prefix=""):
                """ Aggregated view, which uses '=' on every timeslice. """
                # find common time_max
                time_max = 0
                for signal_name in signal_names:
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)
                    time_max = max(time_max, sig_inst['data'][-1][0])

                for signal_name in signal_names:
                    sig_json = {}
                    sig_inst = find_signal_inst(self.data_vcd, signal_name)
                    sig_json['name'] = prefix + sig_inst['name']

                    # [0, time_max]
                    local_time_max = sig_inst['data'][-1][0]
                    wave = ""
                    cur_step_ptr = 0
                    cur_wave = "SOMETHING_NEVER_HAPPEN"
                    data = []

                    # TODO: Avoid multiple transitions at same timestep
                    for i in range(0, local_time_max + 1):
                        if sig_inst['data'][cur_step_ptr][0] > i:
                            # maintain current value
                            wave += "."
                        else:
                            new_wave = self.parseValue(sig_inst['data'][cur_step_ptr][1])
                            if new_wave == cur_wave:
                                wave += "."
                            else:
                                wave += "="
                                data.append(new_wave)
                                cur_wave = new_wave

                            cur_step_ptr += 1

                    for i in range(local_time_max, time_max + 1):
                        wave += "."

                    sig_json['wave'] = wave
                    sig_json['data'] = data

                    self.output['signal'].append(sig_json)

            def addCompare(self,signal_names,prefix1,prefix2,width):
                #have to be the same length and width

                for signal_name in signal_names:

                    signal1 = prefix1 + signal_name
                    signal2 = prefix2 + signal_name

                    for j in range(width):
                        name1 = signal1 +'['+str(j) +']' 
                        get1 = ""
                        wave1 = ""
                        name2 = signal2 +'['+str(j) +']' 
                        get2 = ""
                        wave2 = ""

                        for each in self.output['signal']:
                            if each['name'] == name1:
                                get1 = each['wave']
                            if each['name'] == name2:
                                get2 = each['wave']

                        temp1 = list(get1)
                        temp2 = list(get2)
                        for i in range(len(get1)):
                            if temp1[i] == '.':
                                wave1 += wave1[i-1]
                            else:
                                wave1 += temp1[i]
                        
                            if temp2[i] == '.':
                                wave2 += wave2[i-1]
                            else:
                                wave2 += temp2[i]

                        sig_json = {}
                        sig_json['name'] = "missmatch_" + signal_name + '[' + str(j) + ']'
                        wave = ""
                        get = ""
                        for i in range(len(wave1)):
                            if wave1[i]==wave2[i]:
                                if get == "0":
                                    wave += "." 
                                    get = "0"
                                else:
                                    wave += "0"
                                    get = "0"
                            else:
                                if get == "1":
                                    wave+= "."
                                    get = "1"
                                else:
                                    wave+= "."
                                    get = "1"
                        sig_json['wave'] = wave
                        self.output['signal'].append(sig_json)



        if __name__ == "__main__":
            sample_vcd = {'name': 'root', 'type': {'name': 'struct'}, 'children': [{'name': 'testbench', 'type': {'name': 'struct'}, 'children': [{'name': 'x', 'type': {'width': 3, 'name': 'reg'}, 'data': [(0, 'bx'), (1, 'b0'), (2, 'b1'), (3, 'b10'), (4, 'b11'), (5, 'b100'), (6, 'b101'), (7, 'b110'), (8, 'b111')]}, {'name': 'y', 'type': {'width': 8, 'name': 'wire'}, 'data': [(0, 'bx'), (1, 'b1'), (2, 'b1x'), (3, 'b100'), (4, 'b1000'), (5, 'b10000'), (6, 'b100000'), (7, 'b1000000'), (8, 'b10000000')]}]}]}
            sample_vcd2 = {'name': 'root', 'type': {'name': 'struct'}, 'children': [{'name': 'testbench', 'type': {'name': 'struct'}, 'children': [{'name': 'a', 'type': {'width': 1, 'name': 'reg'}, 'data': [(0, 'x'), (1, '0'), (2, '1'), (3, '0'), (4, '1')]}, {'name': 'b', 'type': {'width': 1, 'name': 'reg'}, 'data': [(0, 'x'), (1, '0'), (3, '1')]}, {'name': 'out', 'type': {'width': 1, 'name': 'wire'}, 'data': [(0, 'x'), (1, '1'), (2, '0'), (4, '1')]}]}]}
            vc = VcdConverter(sample_vcd)
            vc.addToWaveJsonSeparate(['root/testbench/x', 'root/testbench/y'], "mysig_")
            vc.addToWaveJsonAggregated(['root/testbench/x', 'root/testbench/y'], "mysig_")
            print(vc.emitWaveJson())

            vc2 = VcdConverter(sample_vcd2)
            vc2.addToWaveJsonSeparate(['root/testbench/a', 'root/testbench/b', 'root/testbench/out'], "mysig_")
            vc2.addToWaveJsonAggregated(['root/testbench/a', 'root/testbench/b', 'root/testbench/out'], "mysig_")
            print(vc2.emitWaveJson())

